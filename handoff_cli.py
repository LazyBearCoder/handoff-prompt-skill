#!/usr/bin/env python3
"""
Handoff CLI - Manage and search AI continuation documents

Provides commands to list, view, search, and manage handoff documents
generated by the /handoff skill.

Usage:
    python handoff_cli.py list                    # List all handoff documents
    python handoff_cli.py show <filename>         # Show specific handoff
    python handoff_cli.py search "authentication" # Search across all handoffs
    python handoff_cli.py diff <file1> <file2>    # Compare two handoffs
    python handoff_cli.py latest                  # Show the most recent handoff
    python handoff_cli.py extract <file> recent   # Extract specific section

Requirements:
    - Python 3.6+
"""

import os
import sys
import re
import json
import argparse
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional


# Default handoff directory
DEFAULT_HANDOFF_DIR = Path("docs/handoffs")


def find_handoff_directory(start_dir: Path = None) -> Path:
    """
    Find the handoff directory by searching up from current location.
    """
    if start_dir is None:
        start_dir = Path.cwd()

    # Check current directory
    current_handoff = start_dir / DEFAULT_HANDOFF_DIR
    if current_handoff.exists():
        return current_handoff

    # Search up the directory tree
    for parent in [start_dir, *start_dir.parents]:
        check_path = parent / DEFAULT_HANDOFF_DIR
        if check_path.exists():
            return check_path

    # If not found, return the default path
    return DEFAULT_HANDOFF_DIR


def list_handoffs(handoff_dir: Path = None) -> List[Path]:
    """
    List all handoff documents, sorted by modification time (newest first).
    """
    if handoff_dir is None:
        handoff_dir = find_handoff_directory()

    if not handoff_dir.exists():
        return []

    handoffs = []
    for file in handoff_dir.glob("AI_Continuation_Document-*.md"):
        if file.is_file():
            handoffs.append(file)

    # Sort by modification time, newest first
    handoffs.sort(key=lambda f: f.stat().st_mtime, reverse=True)
    return handoffs


def parse_handoff(filepath: Path) -> Dict:
    """
    Parse a handoff document into structured data.
    """
    content = filepath.read_text()

    # Parse sections (markdown ## headers)
    sections = {}
    current_section = None
    current_content = []

    for line in content.split('\n'):
        if line.startswith('## '):
            # Save previous section
            if current_section:
                sections[current_section] = '\n'.join(current_content).strip()

            # Start new section
            current_section = line[3:].strip()
            current_content = []
        else:
            current_content.append(line)

    # Save last section
    if current_section:
        sections[current_section] = '\n'.join(current_content).strip()

    # Extract metadata from filename
    timestamp_match = re.search(r'(\d{2}[A-Za-z]{3}\d{4}-\d{4})', filepath.name)
    timestamp = timestamp_match.group(1) if timestamp_match else "Unknown"

    return {
        "filepath": filepath,
        "filename": filepath.name,
        "timestamp": timestamp,
        "sections": sections,
        "modified": datetime.fromtimestamp(filepath.stat().st_mtime)
    }


def format_file_size(size_bytes: int) -> str:
    """Format file size in human-readable format."""
    for unit in ['B', 'KB', 'MB']:
        if size_bytes < 1024:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024
    return f"{size_bytes:.1f} GB"


def cmd_list(args):
    """List all handoff documents."""
    handoffs = list_handoffs()

    if not handoffs:
        print(f"No handoff documents found in {find_handoff_directory()}")
        print("Create one with: /handoff")
        return 1

    print(f"\n{'='*70}")
    print(f"  Found {len(handoffs)} handoff document(s)")
    print(f"  Directory: {find_handoff_directory()}")
    print(f"{'='*70}\n")

    for i, handoff in enumerate(handoffs, 1):
        parsed = parse_handoff(handoff)

        # Extract project identity if available
        identity = parsed['sections'].get('Project Identity', '')
        first_line = identity.split('\n')[0] if identity else 'No description'

        print(f"{i}. {parsed['filename']}")
        print(f"   Modified: {parsed['modified'].strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"   Size: {format_file_size(handoff.stat().st_size)}")
        print(f"   {first_line[:70]}")
        print()

    return 0


def cmd_show(args):
    """Show a specific handoff document."""
    handoffs = list_handoffs()

    if args.file.lower() == 'latest':
        if not handoffs:
            print("No handoff documents found.")
            return 1
        filepath = handoffs[0]
    elif args.file.isdigit():
        index = int(args.file) - 1
        if index < 0 or index >= len(handoffs):
            print(f"Invalid handoff number. Choose 1-{len(handoffs)}")
            return 1
        filepath = handoffs[index]
    else:
        filepath = find_handoff_directory() / args.file
        if not filepath.exists():
            print(f"Handoff not found: {args.file}")
            return 1

    print(f"\n{'='*70}")
    print(f"  {filepath.name}")
    print(f"{'='*70}\n")

    content = filepath.read_text()
    print(content)

    return 0


def cmd_search(args):
    """Search across all handoff documents."""
    handoffs = list_handoffs()

    if not handoffs:
        print("No handoff documents found.")
        return 1

    query = args.query.lower()
    results = []

    for handoff in handoffs:
        parsed = parse_handoff(handoff)

        # Search in all sections
        for section_name, section_content in parsed['sections'].items():
            if query in section_content.lower():
                # Find matching lines
                matching_lines = []
                for i, line in enumerate(section_content.split('\n'), 1):
                    if query in line.lower():
                        matching_lines.append((i, line.strip()))

                if matching_lines:
                    results.append({
                        'handoff': parsed['filename'],
                        'section': section_name,
                        'matches': matching_lines[:5]  # Limit to 5 matches per section
                    })

    if not results:
        print(f"\nNo matches found for '{args.query}'")
        return 1

    print(f"\n{'='*70}")
    print(f"  Search results for '{args.query}'")
    print(f"  Found {len(results)} matching section(s)")
    print(f"{'='*70}\n")

    for result in results:
        print(f"ðŸ“„ {result['handoff']}")
        print(f"   Section: {result['section']}")
        for line_num, line in result['matches']:
            print(f"   Line {line_num}: {line[:70]}")
        print()

    return 0


def cmd_diff(args):
    """Compare two handoff documents."""
    handoffs = list_handoffs()

    if len(handoffs) < 2:
        print("Need at least 2 handoff documents to compare.")
        return 1

    # Resolve file1
    if args.file1.lower() == 'latest':
        file1 = handoffs[0]
    elif args.file1.isdigit():
        idx = int(args.file1) - 1
        file1 = handoffs[idx] if 0 <= idx < len(handoffs) else handoffs[0]
    else:
        file1 = find_handoff_directory() / args.file1

    # Resolve file2
    if args.file2.lower() == 'latest':
        file2 = handoffs[0]
    elif args.file2.isdigit():
        idx = int(args.file2) - 1
        file2 = handoffs[idx] if 0 <= idx < len(handoffs) else handoffs[0]
    else:
        file2 = find_handoff_directory() / args.file2

    if file1 == file2:
        print("Cannot compare a file with itself.")
        return 1

    parsed1 = parse_handoff(file1)
    parsed2 = parse_handoff(file2)

    print(f"\n{'='*70}")
    print(f"  Comparing handoff documents")
    print(f"{'='*70}\n")

    print(f"OLDER: {file1.name}")
    print(f"       {parsed1['modified'].strftime('%Y-%m-%d %H:%M:%S')}\n")

    print(f"NEWER: {file2.name}")
    print(f"       {parsed2['modified'].strftime('%Y-%m-%d %H:%M:%S')}\n")

    # Compare sections
    all_sections = set(parsed1['sections'].keys()) | set(parsed2['sections'].keys())

    for section in sorted(all_sections):
        content1 = parsed1['sections'].get(section, '')
        content2 = parsed2['sections'].get(section, '')

        if content1 != content2:
            print(f"\n## {section}")
            print(f"   {'(changed)' if content1 and content2 else '(added)' if content2 else '(removed)'}\n")

            if content1 and not content2:
                print(f"   Removed in newer version.")
            elif content2 and not content1:
                print(f"   Added in newer version.")
            else:
                # Both exist but different - show basic diff
                lines1 = content1.split('\n')
                lines2 = content2.split('\n')

                # Show first few differences
                shown = 0
                for i, (l1, l2) in enumerate(zip(lines1[:10], lines2[:10])):
                    if l1 != l2:
                        print(f"   - {l1[:60]}")
                        print(f"   + {l2[:60]}")
                        shown += 1
                        if shown >= 3:
                            break

    return 0


def cmd_extract(args):
    """Extract a specific section from a handoff."""
    handoffs = list_handoffs()

    if not handoffs:
        print("No handoff documents found.")
        return 1

    # Resolve file
    if args.file.lower() == 'latest':
        filepath = handoffs[0]
    elif args.file.isdigit():
        index = int(args.file) - 1
        filepath = handoffs[index] if 0 <= index < len(handoffs) else handoffs[0]
    else:
        filepath = find_handoff_directory() / args.file
        if not filepath.exists():
            print(f"Handoff not found: {args.file}")
            return 1

    parsed = parse_handoff(filepath)

    # Find matching section
    section_name = None
    for name in parsed['sections'].keys():
        if args.section.lower() in name.lower():
            section_name = name
            break

    if not section_name:
        print(f"Section '{args.section}' not found.")
        print(f"Available sections: {', '.join(parsed['sections'].keys())}")
        return 1

    print(f"\n{'='*70}")
    print(f"  {filepath.name} â€” {section_name}")
    print(f"{'='*70}\n")

    print(parsed['sections'][section_name])

    return 0


def main():
    parser = argparse.ArgumentParser(
        description="Manage AI continuation documents",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python handoff_cli.py list              List all handoffs
  python handoff_cli.py show latest        Show most recent handoff
  python handoff_cli.py show 1             Show handoff #1
  python handoff_cli.py search "billing"   Search for 'billing'
  python handoff_cli.py diff 1 2           Compare handoffs #1 and #2
  python handoff_cli.py extract latest recent-work  Extract 'Recent Work' section
        """
    )

    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # List command
    subparsers.add_parser('list', help='List all handoff documents')

    # Show command
    show_parser = subparsers.add_parser('show', help='Show a specific handoff')
    show_parser.add_argument('file', help='Filename, "latest", or number')

    # Search command
    search_parser = subparsers.add_parser('search', help='Search across handoffs')
    search_parser.add_argument('query', help='Search query')

    # Diff command
    diff_parser = subparsers.add_parser('diff', help='Compare two handoffs')
    diff_parser.add_argument('file1', help='First file (filename, "latest", or number)')
    diff_parser.add_argument('file2', help='Second file (filename, "latest", or number)')

    # Extract command
    extract_parser = subparsers.add_parser('extract', help='Extract a section')
    extract_parser.add_argument('file', help='Filename, "latest", or number')
    extract_parser.add_argument('section', help='Section name (partial match)')

    # Latest shortcut
    subparsers.add_parser('latest', help='Show the most recent handoff')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # Map commands to functions
    commands = {
        'list': cmd_list,
        'show': cmd_show,
        'search': cmd_search,
        'diff': cmd_diff,
        'extract': cmd_extract,
        'latest': lambda args: cmd_show(type('Args', (), {'file': 'latest'})())
    }

    handler = commands.get(args.command)
    if handler:
        return handler(args)

    return 1


if __name__ == "__main__":
    sys.exit(main())
